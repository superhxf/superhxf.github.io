# 数据结构和算法大全

​	我一直认为，数据结构和算法是程序员的灵魂，哪怕换了n多的框架，甚至是换了语言，当然也有人说设计模式是程序员的血肉，这个我也赞同、

## 1、复杂度分析

​	数据结构和算法本身是为了解决块和省的问题，代码如何运行的更快，如何让代码更省存储空间，执行效率是算法一个非常重要的考量指标。

​    大O复杂度表示法

```
T(n) = O (f(n))
```

T(n)代表代码执行的总时间，n代表的数据量，f(n)代表的是每行代码执行的次数总和。

大O复杂度表示方法只是一种变化趋势，通常我们会忽略掉公式中的常量，低阶，系数，只需要几类一个最大阶的量级就可以了。

如何分析一段程序的复杂度，一般有三种比较实用的方法

1. 只关注循环执行次数最多的一段代码
2. 加法法则，总的复杂度等于量级最大的那段代码的复杂度。
3. 乘法法则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

常见的时间复杂度大概有以下几种，常量阶O(1),对数阶O(logn),线性阶O(n),线性对数阶O(nlogn),平方节O(n2)等

空间复杂度比时间复杂度要简单很多，大概有以下几种，O(1),O(n),O(n2)。

最好，最坏情况时间复杂度分析，就是分析程序的极端场景，最好场景是复杂度是多少，最坏场景复杂度是多少。

平均情况时间复杂度分析，就是每种情况乘以发生概念相加之后再除以情况总数。

均摊时间复杂度，其实就是在程序中，如果出现两个操作执行数量一致，一个耗时多，一个耗时少，两者可以均摊来计算时间复杂度。

## 2、数据结构

### 2.1、数组

​	定义，数组是一种线性表数据结构，用一组连续的内存空间，存储一组具有相同类型的数据。

​    数据由于线性表和连续的内存空间要求，让它具备了随机访问的特性，但是对于删除，插入则效率就会低很多。

   提到数据不得不提到java语言的容器 ArrayList，是否可以完全替代数据，ArrayList的底层实现就是数据，但是ArrayList在上层做了动态扩容，扩容比例是1.5,扩容的时候涉及到了内存申请和数据搬移，就会比较浪费时间。

数组和容器最大的一个使用区别在于，数据可以存放基本类型，但是容器只能存储基本类型对应的包装类，在自动拆箱和装箱这个过程中，比较耗费时间。

### 2.2、链表

​	定义，链表通过指针（引用）将一组零散的内存块串联到一起，每一个内存块称之为节点，每个节点上不仅要存储数据，还有记录下一个节点的地址。

​	链表有很多中表现形式，比如单向链表，双向链表，循环链表，双向循环链表等。

​    和数组比较起来，链表由于特殊的数据结构，在插入，删除方面的性能很高，只需要修改指针即可，垃圾回收交给GC。

​    但是查找，遍历就会很麻烦，这块可能会有一个考虑的点，数据和链表都是遍历的话，都是从头结点到查找的那个点，时间不应该一样么？其实是不一样的，现代计算机为了弥补cpu和内存之间的速度差异，每次从内存中获取数据，取得不是一个点，而是一个块，也就是我要取值得前后都会直接缓存起来，数组是连续的，所以可能每十个点才去内存中去一次，但是链表可能就是每次都去，所以，数组遍历的耗时要比链表少得多。

如何实现LUR缓存淘汰算法

​	首先，都知道缓存是一种提高数据读取的技术，往往web服务的性能瓶颈在数据库这块，缓存使用的是内存，内存是很宝贵的，当缓存空间满的时候，哪些数据应该清理，就需要指定缓存策略，常见的策略有三种，先进先出策略（FIFO），最少使用策略（LFU），最近最少使用策略（LUR）。

​    链表如何实现呢，比如我们维护一个有序的单链表，越靠近链表尾部是越早放完的，当一个新的数据被访问的时候，我们从链表头开始顺序遍历链表，有两种情况

1. 数据存在，找到这个数据，删除，插入到头部。
2. 数据不存在，链表已满，删除尾部节点，将数据插入头部节点，链表未满，将数据直接插入头部。

其实还有点问题，比如，缓存访问的时间复杂度是O(n)，必须把缓存访问的时间复杂度降级，可以引入散列表来记录缓存位置，就可以降低访问复杂度了。

### 2.3、栈

​        定义，关于“栈”，我有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。后进者先出，先进者后出，这就是典型的“栈”。

​        栈的底层可以用数组，也可以用链表，它隐藏了很多操作，只对外提供了头部访问的方式，时间复杂度，空间复杂度都是很低。

​    栈的应用场景

1. 浏览器的前进后退，就可以用栈实现，维护了两个栈。
2. 比如括号校验，使用栈来做。
3. 比如算法表达式的操作系统内部实现。

内存中的堆栈和这个栈不是一个概念，内存中是实实在在存在存储，物理区，存储着运行方法的形参，局部变量，返回值等。

### 2.4、队列

​        队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”，队列经常和栈做比较，我们知道，栈只支持两个基本操作：入栈push()和出栈pop()。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。

​      跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。

   跟栈不一样的地方在于，队列是先进先出的，所以，在存储这块就会出现，站位后移的情况，如果用数组的话就可以使用数据搬移，设计的时候，其实可以做成当空间满的时候，在进行搬移，空间不满直接用就可以了。

​    换一种，换一个思路，如果采用循环链表呢，就省去了搬移的过程，但是需要加上判断条件，队列空的条件头等于尾，队列满的条件，尾加上1 除以总个数 取余等于头。

队列的使用场景

​	阻塞队列和并发队列，阻塞队列就是在队列的基础上加了阻塞操作，队列为空的时候，对头取数据就会阻塞，队列满的时候，插入数据会阻塞。

   并发队列最简单的操作，在进入队列，和出队列的时候增加同步锁，就可以实现，但是效率会很多，其实大部分项目中采用的是CAS原子操作。

   入队前获取tail位置，入队比较尾部位置是否变化，没有变化则入队，否则不入队，出队则是获取头部位置，就行cas。

## 3、操作

### 3.1、递归操作

​      递归是一种应用非常广泛的算法（或者编程技巧）。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。

​    递归是一个

​	



​	



  

​    







