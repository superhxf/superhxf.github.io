---

layout: post

title: 聊聊从代码管理到自动化发布

categories: CICD

tag: CICD

---

## 前言

​	   容器时代到来之后，代码自动化部署从纸上谈兵跃迁到生产实践，jira，禅道等为代表的项目需求管理工具，gitlab为代表的代码版本管理工具，传统的jenkins自动化任务工具，新兴的gitlabCI ，jenkinsX等云上自动化任务应用工具为代表的的自动化发布核心流程工具，docker，k8s ，helm 层级逐渐递增的容器部署及容器编排部署工具，配合周边的一些持久化工具，质量检查工具，自动化测试工具，甚至是OA审批流，整合了需求把控，代码管理，自动化发布及相关内容。

## 谈谈git flow

### 	什么是git flow

​     git flow版本管理流程，可以满足绝大部分企业的代码管理规范流程，git分布式代码管理工具成为企业代码版本工具的标准之后，小到几人的微服务开发者，大到数百人的单体巨应用的开发者，都是用git作为版本管理工具，人越多，就需要制定标准，git flow就是结合git强大的分支管理提出的一个标准或者规范。

​    git flow解决了什么问题

1. 由于很容易去创建分支，分支多了如何管理，这么多的分支都是做什么的？
2. 如何开始一个需求分支，而不影响其他需求分支的正常开发过程？
3. 哪些分支已经合并到了主分支，哪些分支应该废弃掉？
4. 发布分支如何管理? 开始一个release分支的时候如何冻结feature分支，如何在prepare release的时候，不影响开发人员在feature继续开发？
5. 线上出现了紧急bug，如何快速修复，并且修复的问题要包含到开发人员的分支以及下一个relase分支中？

​     现状

​	   大部分的应用，项目使用git作为版本管理，只是用两个甚至三个分支，Master线上分支，develop主开发分支，然后就是一个乱七八糟的各种命名的分支，这种情况，在小产品，小团队，小项目中还可以支撑，一旦规模起来之后，那将是灾难性的。

### 	git flow的分支

​		![](https://github.com/superhxf/superhxf.github.io/blob/master/_posts/images/o_git-flow-nvie.jpg?raw=true)

​     在git flow分支分类一般是五类，分别是

- Production 分支

也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支做任何的修改。

- Develop 分支

这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。

- Feature 分支

这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。

- Release分支

当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。

- Hotfix分支

当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。



梳理一下一个产品从开发到上线再到二版本上线的整个过程

1. 主程序员（产品开发负责人）创建本地和远端仓库，初始分支为master，此分支作为线上分支，不允许做任何的直接改动。
2. 基于master检出develop分支，作为开发主分支，开始分配开发人员权限。
3. 分配需求，不同的需求创建不同的feature分支，要求这些需求开发最大化隔离，不要互相依赖，在开发基于develop创建新的feature分支的时候，提交向develop的merge request，任何问题和代码沟通都可以在merge request中和主程序员沟通。
4. feature开发完成，要求开发人员自测联调通过，并联系主程序员 review merge request，主程序员决定是否可以接受本次merge request，接受同意merge 关闭merge request。
5. 上线负责人（一般也是主程序员或者开发经理），基于develop检出relase分支，准备上线，在切出之前合并到develop的需求作为本次上线内容，部署到预生产环境，提交测试，一期测试人员介入，二期业务人员介入。
6. 在release测试的任何问题，都基于relase分支切出hotfixs分支进行紧急修复，修复完成之后，合并回relase分支，主程序员要判断本次修改是否会影响到feature，如何有影响，则develop要合并release分支内容，并同步给开发人员，在合并到feature继续开发，如果无影响，并所有的测试问题修复，则开始准备上线内容，最后修改应用版本为v1.0，并在版本页面或者数据库记录本次发版内容，relase分支打tag 比如v1.0,merge 到master分支上，作为本次上线内容。merge回develop分支，同步relase的修改，本次release分支一直停留到下次relase发布前。
7. 基于master分支打出本次上线内容程序包（目前一般都是镜像），部署生产环境，开放业务使用。
8. 在master上使用出现了紧急bug，基于relase分支切出新的hotfixs分支进行紧急修复，修复完成，合并到release分支，在预生产环境交给测试和业务确认之后，提交线上修复审批，同意之后，修改小版本号，比如v1.0.01版本，在版本页或者数据库记录本次发版内容，同步到master分支，发版。
9. 开发人员完成新的上线需求，主开发人员同意merge请求，处理完上个release分支的事务，提出新的release分支，开始测试，同样要经历bug修复等等。
10. 测试，业务测试通过之后，主程序员修改版本号和记录本次版本迭代内容，打tag，记录本次版本，比如v1.1,合并到master和develop分支，master制作新的程序发布包（镜像），滚动升级，灰度发布，主键扩大新版本覆盖策略。











​	

​    