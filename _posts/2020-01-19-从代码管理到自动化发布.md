---

layout: post

title: 聊聊从代码管理到自动化发布

categories: CICD

tag: CICD

---

## 前言

​	   容器时代到来之后，代码自动化部署从纸上谈兵跃迁到生产实践，jira，禅道等为代表的项目需求管理工具，gitlab为代表的代码版本管理工具，传统的jenkins自动化任务工具，新兴的gitlabCI ，jenkinsX等云上自动化任务应用工具为代表的的自动化发布核心流程工具，docker，k8s ，helm 层级逐渐递增的容器部署及容器编排部署工具，配合周边的一些持久化工具，质量检查工具，自动化测试工具，甚至是OA审批流，整合了需求把控，代码管理，自动化发布及相关内容。

## 谈谈git flow

### 	什么是git flow

​     git flow版本管理流程，可以满足绝大部分企业的代码管理规范流程，git分布式代码管理工具成为企业代码版本工具的标准之后，小到几人的微服务开发者，大到数百人的单体巨应用的开发者，都是用git作为版本管理工具，人越多，就需要制定标准，git flow就是结合git强大的分支管理提出的一个标准或者规范。

​    git flow解决了什么问题

1. 由于很容易去创建分支，分支多了如何管理，这么多的分支都是做什么的？
2. 如何开始一个需求分支，而不影响其他需求分支的正常开发过程？
3. 哪些分支已经合并到了主分支，哪些分支应该废弃掉？
4. 发布分支如何管理? 开始一个release分支的时候如何冻结feature分支，如何在prepare release的时候，不影响开发人员在feature继续开发？
5. 线上出现了紧急bug，如何快速修复，并且修复的问题要包含到开发人员的分支以及下一个relase分支中？

​     现状

​	   大部分的应用，项目使用git作为版本管理，只是用两个甚至三个分支，Master线上分支，develop主开发分支，然后就是一个乱七八糟的各种命名的分支，这种情况，在小产品，小团队，小项目中还可以支撑，一旦规模起来之后，那将是灾难性的。

### 	git flow的分支

​		![](https://github.com/superhxf/superhxf.github.io/blob/master/_posts/images/o_git-flow-nvie.jpg?raw=true)

​     在git flow分支分类一般是五类，分别是

- Production 分支

也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支做任何的修改。

- Develop 分支

这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。

- Feature 分支

这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。

- Release分支

当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。

- Hotfix分支

当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。



梳理一下一个产品从开发到上线再到二版本上线的整个过程

1. 主程序员（产品开发负责人）创建本地和远端仓库，初始分支为master，此分支作为线上分支，不允许做任何的直接改动。
2. 基于master检出develop分支，作为开发主分支，开始分配开发人员权限。
3. 分配需求，不同的需求创建不同的feature分支，要求这些需求开发最大化隔离，不要互相依赖，在开发基于develop创建新的feature分支的时候，提交向develop的merge request，任何问题和代码沟通都可以在merge request中和主程序员沟通。
4. feature开发完成，要求开发人员自测联调通过，并联系主程序员 review merge request，主程序员决定是否可以接受本次merge request，接受同意merge 关闭merge request。
5. 上线负责人（一般也是主程序员或者开发经理），基于develop检出relase分支，准备上线，在切出之前合并到develop的需求作为本次上线内容，部署到预生产环境，提交测试，一期测试人员介入，二期业务人员介入。
6. 在release测试的任何问题，都基于relase分支切出hotfixs分支进行紧急修复，修复完成之后，合并回relase分支，主程序员要判断本次修改是否会影响到feature，如何有影响，则develop要合并release分支内容，并同步给开发人员，在合并到feature继续开发，如果无影响，并所有的测试问题修复，则开始准备上线内容，最后修改应用版本为v1.0，并在版本页面或者数据库记录本次发版内容，relase分支打tag 比如v1.0,merge 到master分支上，作为本次上线内容。merge回develop分支，同步relase的修改，本次release分支一直停留到下次relase发布前。
7. 基于master分支打出本次上线内容程序包（目前一般都是镜像），部署生产环境，开放业务使用。
8. 在master上使用出现了紧急bug，基于relase分支切出新的hotfixs分支进行紧急修复，修复完成，合并到release分支，在预生产环境交给测试和业务确认之后，提交线上修复审批，同意之后，修改小版本号，比如v1.0.01版本，在版本页或者数据库记录本次发版内容，同步到master分支，发版。
9. 开发人员完成新的上线需求，主开发人员同意merge请求，处理完上个release分支的事务，提出新的release分支，开始测试，同样要经历bug修复等等。
10. 测试，业务测试通过之后，主程序员修改版本号和记录本次版本迭代内容，打tag，记录本次版本，比如v1.1,合并到master和develop分支，master制作新的程序发布包（镜像），滚动升级，灰度发布，逐渐扩大新版本覆盖策略。

## 谈谈应用版本号策略

​    应用版本号管理，版本号对于应用来讲，就像是gitlab对于源码，在程序员的世界中，任何内容都需要版本的概念，来归档，升级，回退等等，保证应用的稳定和规范化，国内外制定了很多套标准用于版本号管理，不一一列举，只拿出最常用的一个版本号管理规范。

#### 列举一个国内比较常用的版本号策略

1. ​	正常的版本号必须使用X.Y.Z的形式并且X/Y/Z是非负整数。X是主版本号，Y是次版本号，Z是补丁版本号。版本号每次必须只能增长1。例如：1.9.0->1.10.0->1.11.0。
2. 当主版本号增长时，次版本号和补丁版本号必须清零。当次版本号增长时，补丁版本号必须清零。例如：1.1.9->2.0.0，2.1.7->2.2.0。
3. 一旦发布了具有版本的包，那个版本的内容必须不能再更改。任何修改必须发布成一个新版本。
4. 主版本号0 (0.y.z)是用来进行初始开发时使用的。任何东西都可能在任何时候改变。公共API此时应该被认为是经常变动的。
5. 版本1.0.0开始为对外发布正式版。这个版本及以后的版本号的增长方式将依赖于对公部分以及它如何变化。
6. 如果单一子产品有任何向下兼容的bug修复发生，补丁版本号Z (x.y.Z | x > 0)必须增长1。“bug修复”被定义为内部进行的修复非正常行为的修复工作。
7. 如果单一子产品进行了新的并且向下兼容的对公部分添加、优化、修改，次版本号Y (x.Y.z | x > 0)必须增长1。如果任何公共API被标记为“过期”，次版本号必须增长1；如果有大量的新功能或改进在内部代码中发生，次版本号可以增长1；这其中也可以包含补丁级别的修改。当次版本号增长时补丁版本号必须清零。
8. 如果单一子产品对公共API有任何向下不兼容的修改，或者两个及两个以上子产品同时发布新特性，或者主产品开辟新业务模式，主版本号X (X.y.z | X > 0)必须增长1。这其中也可以包含次版本和补丁版本级别的修改。当主版本号增长时次版本号和补丁版本号必须清零。

## 谈谈自动化发布

自动化发布要分为两块来讲，自动化一块，发布一块，先聊聊发布这个过程

### 发布

​	当源码测试通过，发布流程审批通过之后，这个应用就应该要发布了，发布前要做哪些事情呢？

1. 源码管理按照git flow规范去走，具体参考上文谈谈 git flow
2. 发布版本严格按照版本规范去走，具体参考谈谈应用版本号策略
3. 发布流程严格按照公司内部规定，比如，发布需要流程申请，通过审批之后发布
4. 发布前严格测试数据库脚本，脚本需要制作正逆两个，发布使用正向脚本，版本回退使用逆向发布，如果是不可回退发布，则需要停服，备库。
5. 发布前对新增的配置信息严格测试，例如发布配置清单内容，切不可丢失配置信息。
6. 尽可能的使用滚动升级，保证服务对外无损。





​	
