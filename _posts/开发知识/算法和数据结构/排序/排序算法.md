

# 十大排序算法

##   a、冒泡排序

  大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面，这个过程类似于水泡向上升一样。

```
package com.example.sort;
/**
 * @author haoxiaofei 
 * @time 2019-07-16
 */
public class BubbleSort {
	/**
	 * 对sortedArray进行排序  
	 *  时间复杂度：O(n*n)	
	 *  空间复杂度：O(n)
	 * 牺牲了时间换来了空间
	 * @param sortedArray 需要处理的数组
	 * @param isAsc 是否升序
	 * @return
	 */
	public static int[] bubbleSort(int[] sortedArray,boolean isAsc) {
		if(isAsc) {
			for(int i = 0; i < sortedArray.length; i ++) {
				for(int j = 0; j < i ; j++) {
					if(sortedArray[i] < sortedArray[j]) {
						swap(sortedArray,i,j);
					}
				}
			}
		}else {
			for(int i = 0; i < sortedArray.length; i ++) {
				for(int j = 0; j < i ; j++) {
					if(sortedArray[i] > sortedArray[j]) {
						swap(sortedArray,i,j);
					}
				}
			}
		}
		return sortedArray;	
	}
	/**
	 * 数据交换
	 * @param array
	 * @param i
	 * @param j
	 */
	private static void swap(int[] array,int i , int j) {
		int tmp = array[i];
		array[i] = array[j];
		array[j] = tmp;
	}
     /**
            *  测试排序效果
      * @param args
      */
	public static void main(String[] args) {
		
		int[] sortedArray = {1,6,9,4,8,2,5};
		sortedArray = bubbleSort(sortedArray,true);
		for(int i : sortedArray) {
			System.out.print(i);
		}
		sortedArray = bubbleSort(sortedArray,false);
		for(int i : sortedArray) {
			System.out.print(i);
		}
	}
}
```

##    b、选择排序

  选择排序的思想和冒泡排序的思想类似，都是一趟排序之后，把小的排到前面，但是过程是不同的，冒泡拍下是相邻的两个元素进行比较，而选择排序则是通过对整体进行选择，将最小和最前面的进行交换，之后再对剩下的进行排序。

```
package com.example.sort;
/**
 * 选择排序
 * @author haoxiaofei
 * @time 2019-07-16
 */
public class SelectSort {
	/**
	   * 选择排序 
         对sortedArray进行排序  
	 *  时间复杂度：O(n*n)	
	 *  空间复杂度：O(n)
	 * @param sortedArray
	 * @return
	 */
	public static int[] selectSort(int[] sortedArray) {
		for(int i = 0; i < sortedArray.length; i ++) {
			int minIndex = i;
			for(int j = i; j < sortedArray.length; j++) {
				if(sortedArray[minIndex] > sortedArray[j]) {
					minIndex = j;
				}
			}
			swap(sortedArray,minIndex,i);
		}
		return sortedArray;
	}
	
	/**
	 * 数据交换
	 * @param array
	 * @param i
	 * @param j
	 */
	private static void swap(int[] array,int i , int j) {
		int tmp = array[i];
		array[i] = array[j];
		array[j] = tmp;
	}
	 /**
	     *  测试排序效果
	     * @param args
	*/
	public static void main(String[] args) {
		int[] sortedArray = {1,6,9,4,8,2,5};
		sortedArray = selectSort(sortedArray);
		for(int i : sortedArray) {
			System.out.print(i);
		}
	}
}
```

## c、插入排序

插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的，假设前面两个是有序的，则取出第三个在前面两个比对，放到合适的位置。

```
package com.example.sort;
/**
  * 插入排序
 * @author haoxiaofei
 * @time 2019-07-16
 */
public class InsertSort {
	/**
	 * 插入排序 
	 * 时间复杂度 O(n*n)
	 * 空间复杂度 O(n)
	 * @param sortedArray
	 * @return
	 */
	public static int[] insertSort(int[] sortedArray) {
		for(int i = 1 ; i < sortedArray.length ; i ++) {
			for(int j = 0; j < i ; j ++) {
				if(sortedArray[i] < sortedArray[j]) {
					int tmp = sortedArray[j];
					sortedArray[j] = sortedArray[i];
					int k = i;
					while(k > j+1) {
						sortedArray[k] = sortedArray[k-1];
						k--;
					}
					sortedArray[j+1] = tmp;
					break;
				}
			}
		}
		return sortedArray;
	}
	
	 /**
	     *  测试排序效果
	  * @param args
	*/
	public static void main(String[] args) {
		int[] sortedArray = {1,6,9,4,7,3,2};
		sortedArray = insertSort(sortedArray);
		for(int i : sortedArray) {
			System.out.print(i);
		}
   }
}
```

## d、希尔排序（缩小增量法）

希尔排序是是国外的一个叫做shell的人发明的，希尔排序有一个很重要的概念，就是希尔增量序列，给予这个序列就可以把数组分为多少个组，所有相距这个序列大小的值为一组，在这个组内进行插入排序，之后缩小希尔值，比例为原来的二分之一，在分组，组内再做插入排序，希尔排序可以称之为插入排序的高级版。

```
package com.example.sort;
/**
 * @author haoxiaofei
 */
public class ShellSort {
	/**
	 * 希尔排序
	 * 时间复杂度： O(n*logn - n*n)
	 * 空间复杂度：O(n)
	 * 
	 * @param sortedArray
	 * @return
	 */
	public static int[] shellSort(int[] sortedArray) {
		//对希尔增量序列进行操作 每次都取上次的一半
		int step = sortedArray.length/2;
		//每次step都会取上一次的二分之一
		while(step >= 1) {
			//间隔step的元素为一组，进行直接插入排序计算。
			for(int i = step; i < sortedArray.length; i += step) {
				for(int j = 0; j < i; j += step) {
					if(sortedArray[i] < sortedArray[j] ) {
						//暂存一下sortedArray[j]
						int tmp = sortedArray[j];
						sortedArray[j] = sortedArray[i];
						//剩下的依次位移
						int index = i;
						while(index > j + step) {
							sortedArray[index] = sortedArray[index-step];
							index -= step;
						}
						sortedArray[index] = tmp;
						break;
					}
				}
			}
		   //取上一次的二分之一
			step = step/2;
		}
		return sortedArray;
	}
	 /**
	     *  测试排序效果
	  * @param args
	*/
	public static void main(String[] args) {
		int[] sortedArray = {1,6,9,4,7,3,2};
		sortedArray = shellSort(sortedArray);
		for(int i : sortedArray) {
			System.out.print(i);
		}
	}
}
```

## e、归并排序

 归并排序

## f、快速排序



## g、堆排序

## h、计数排序

## i、桶排序

## j、基数排序





